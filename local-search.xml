<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>矩阵加速递推学习笔记---从快速幂讲起</title>
    <link href="/2025/08/13/%E7%9F%A9%E9%98%B5%E5%8A%A0%E9%80%9F%E9%80%92%E6%8E%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%8E%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%B2%E8%B5%B7/"/>
    <url>/2025/08/13/%E7%9F%A9%E9%98%B5%E5%8A%A0%E9%80%9F%E9%80%92%E6%8E%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%8E%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%B2%E8%B5%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>首先，我们思考一个简单的问题：</p><ul><li>给定你$a,b,p$，如何快速计算$a^b\bmod p $</li></ul><p>最简单的思路便是把$a$连续乘$b$次，在每次乘的时候都取一次模<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> ans = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span>(b--)&#123;<br>    ans = (ans*a) % p;<br>&#125;<br></code></pre></td></tr></table></figure><br>显而易见，这样写算法复杂度过大，我们需要一个更简便的算法。那我们该如何优化呢？<br>把$b$拆开，拆成形如$a^{b_1} \times a^{b_2} \times a^{b_3} \times a^{b_4} \times  \ldots  \times a^{b_n}(b = b_1+ \ldots +b_n)$的式子，这样，我们尝试减小n，便可以减小算法复杂度了。<br>那么，如何减小呢？<br>用一个例子来说明：假设$b = 5$，则其二进制形式为$b = (101)_2$，注意到了吗，结果可以表示为$a^{(1)_2 \times 1} \times a^{(10)_2 \times 0} \times a^{(100)_2 \times 1}$，我们成功地将$O(n)$的复杂度降到了$O( \log{}{n})$。以下是详细的过程：将$b$转换为$2$进制，从最低位开始，依次检查是否为$1$，如果是，将$ans$乘上$b$对应的位权次$a$。但仅仅这样还不够，“将$ans$乘上$b$对应的位权次$a$”，若仍朴素地乘，则复杂度没有变，所以在每次检查下一位时，都让$a$平方一次，由于是二进制，所以这样操作后$a$刚好是$b$的位权次幂。接下来就是简短的代码啦<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int unsigned long long</span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a,b,p;<br>    cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;<br>    <span class="hljs-type">int</span> aa = a,bb = b;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b &gt; <span class="hljs-number">0</span>)&#123;<br>        a %= p;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)&#123;<br>            ans *= a;<br>        &#125;<br>        ans %= p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>        a *= a;<br>    &#125;<br>    cout&lt;&lt;aa&lt;&lt;<span class="hljs-string">&#x27;^&#x27;</span>&lt;&lt;bb&lt;&lt;<span class="hljs-string">&quot; mod &quot;</span>&lt;&lt;p&lt;&lt;<span class="hljs-string">&#x27;=&#x27;</span>&lt;&lt;ans % p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><a href="https://www.luogu.com.cn/problem/P1226">模板题(洛谷P1226)</a></p><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>知道了快速幂之后，矩阵快速幂就很简单啦。所以为了<del>水字数</del>照顾那些不会矩阵乘法的人，就在这里讲一下矩阵乘法的定义叭。<br><strong>矩阵</strong>，可以理解成一个二维数组，它长成这个样子：</p><p><br><center>$A = \begin{bmatrix}    1 & 2 & -4 \\    5 & -2 & 7 \\    3 & -3 & 6\end{bmatrix} $</center><br></p><p>更一般的，一个 $m \times n$ 的矩阵是一个由 $m$ 行 $n$ 列元素排列成的矩形阵列。它长成这个样子：</p><p><br><center>$ A = \begin{bmatrix} a_{1 1} & a_{1 2} & \cdots & a_{1 n} \\ a_{2 1} & a_{2 2} & \cdots & a_{2 n} \\ \vdots & \vdots & \ddots & \vdots \\ a_{m 1} & a_{m 2} & \cdots & a_{m n} \end{bmatrix} \text{.} $</center><br></p><p>大多数题中矩阵中的元素 $a_{i j}$ 都是整数。</p><p>两个大小分别为 $m \times n$ 和 $n \times p$ 的矩阵 $A, B$ <strong>相乘</strong>的结果为一个大小为 $m \times p$ 的矩阵。将结果矩阵记作 $C$，则</p><p><br><center>$ c_{i j} = \sum_{k = 1}^{n} a_{i k} b_{k j} \text{, ($1 \le i \le m$, $1 \le j \le p$).} $</center><br></p><p>是不是有点懵？没关系，看下面这张图(表示左边的矩阵$A$乘上边的矩阵$B$)：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/8ryegt04.png" alt=""><br>结果矩阵的第一个元素为$a_{1,1}b_{1,1}+a_{1,2}b_{2,1}+a_{1,3}b_{3,1}$，其他同理<br>显然，矩阵乘法不满足交换律(这个例子满足是因为两个矩阵完全相同)。而且，左边的矩阵的<strong>列数</strong>必须等于右边矩阵的<strong>行数</strong>才可以相乘(否则$a_{i,j}$就找不到TA的另一半了ww)</p><p>不那么显然，矩阵乘法满足结合律，即 $(A B) C = A (B C)$。为什么呢？自己试一下就知道啦。</p><p>现在，我们要求出<br><br><center>$A^k = \underbrace{A \times A \times \cdots \times A}_{k \text{ 次}}$</center><br><br>且矩阵中所有元素对$10^9+7$取模。<br><br>发现了吗，如果把这题里的矩阵换成单个数字，这不就是快速幂的模板题嘛。不过我们还要解决一件事，写快速幂时，我们将结果初始值设为$1$，因为任何数乘$1$结果都不变，且除$0$外，任何数的$0$次幂均为$1$。那么矩阵里有类似的东西吗？</p><p><br><center>定义 $A^0$ 为单位矩阵 $I = \begin{bmatrix} 1 & 0 & \cdots & 0 \\ 0 & 1 & \cdots & 0 \\ \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & \cdots & 1 \end{bmatrix}$。</center><br></p><p>容易发现，这个矩阵确实有”$1$”的那些性质。<br>接下来，就是愉快地写代码啦<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> ll MOD=<span class="hljs-number">1000000007</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mtx</span>&#123;<br>    ll m[<span class="hljs-number">200</span>][<span class="hljs-number">200</span>];<br>&#125;A,C;<br>ll n,k;<br>mtx <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> mtx &amp;x,<span class="hljs-type">const</span> mtx &amp;y)&#123;<br>    mtx c;<br>    <span class="hljs-built_in">memset</span>(c.m,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c.m));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>                c.m[i][j] += ((x.m[i][k]%MOD)*(y.m[k][j]%MOD))%MOD;<br>            &#125;<br>            c.m[i][j] %= MOD;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            cin&gt;&gt;A.m[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        C.m[i][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(k&amp;<span class="hljs-number">1</span> == <span class="hljs-number">1</span>)&#123;<br>            C = C*A;<br>        &#125;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>        A = A*A;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            cout&lt;&lt;C.m[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><a href="https://www.luogu.com.cn/problem/P3390">模板题(洛谷P3390)</a></p><h2 id="矩阵加速递推"><a href="#矩阵加速递推" class="headerlink" title="矩阵加速递推"></a>矩阵加速递推</h2><p>前面那么多有什么用呢？用来加速递推！怎么用呢？别急，先来看个例子</p><p>我们知道，斐波那契数列是满足如下性质的一个数列：</p><p><br><center>$F_n = \left\{\begin{aligned} 1 \space (n \le 2) \\ F_{n-1}+F_{n-2} \space (n\ge 3) \end{aligned}\right.$</center><br></p><p>现在，我们要求出 $F_n \bmod 10^9 + 7$ 的值。</p><p>咱们都学了矩阵快速幂了，肯定不是线性递推啦。考虑把对当前项$F_n$有用的项竖着放到一个矩阵里(称为列向量)，长成这个样子(下面的所有矩阵的排列方式都不用太纠结，谁在前谁在后都一样，自己写熟练了怎么写都行)：</p><p><br><center>$A = \begin{bmatrix}    F_{n-2}\\    F_{n-1}\end{bmatrix} $</center><br></p><p>可以根据这个矩阵推出下一个矩阵：</p><p><br><center>$A' = \begin{bmatrix}    F_{n-1}\\    F_{n}\end{bmatrix} $</center><br></p><p>如果我们从第一个矩阵开始推，不就可以这样推出第n项了吗。那”推”是怎么推的呢？对于第二个矩阵，我们需要第一个矩阵的什么呢？需要$a_{2,1}$和$a_{1,1}+a_{2,1}$，并把这两项竖着排列。根据拉格朗日插值法的思想，不要的东西我们就乘$0$，要的东西就乘$1$，我们需要一个$0 \times a_{1,1}+1 \times a_{2,1}$和一个$1 \times a_{1,1}+1 \times a_{2,1}$，也就是</p><p><br><center>$A' = \begin{bmatrix}    0 \times F_{n-2}+1 \times F_{n-1}\\    1 \times F_{n-2}+1 \times F_{n-1}\end{bmatrix} $</center><br><br>(这里还有一种理解方式，就是把$A’$矩阵里的元素拆开，用$A$矩阵里的元素表示，再用$0$补齐，使其对称)<br><br><br>欸，这怎么这么眼熟，这不就是</p><p><br><center>$\begin{bmatrix}    0 & 1\\    1 & 1\end{bmatrix} \times A$</center><br><br>得到的结果嘛。所以”推”这个过程，其实就是一个我们构造的矩阵乘上原始矩阵，推几次就乘几次。欸，好眼熟的说法，”乘几次”，可以用矩阵快速幂来乘！最终结果便是</p><p><br><center>$\begin{bmatrix}    0 & 1\\    1 & 1\end{bmatrix}^{n-2} \times \begin{bmatrix}    1\\    1\end{bmatrix}$</center><br></p><p>至于为什么是$n-2$次呢？请自行思考<br>代码~<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1000000007</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mtx</span>&#123;<br>    ll m[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>&#125;A,F;<br>mtx <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> mtx &amp;x,<span class="hljs-type">const</span> mtx &amp;y)&#123;<br>    mtx c;<br>    <span class="hljs-built_in">memset</span>(c.m,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c.m));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j  = <span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">2</span>;k++)&#123;<br>                c.m[i][j] = (c.m[i][j]+x.m[i][k]*y.m[k][j])%MOD;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    n -= <span class="hljs-number">2</span>;<br>    mtx C;<br>    C.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;C.m[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;C.m[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;C.m[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    A.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;A.m[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;A.m[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;A.m[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//cout&lt;&lt;C.m[1][1]&lt;&lt;&#x27; &#x27;&lt;&lt;C.m[1][2]&lt;&lt;endl&lt;&lt;C.m[2][1]&lt;&lt;&#x27; &#x27;&lt;&lt;C.m[2][2]&lt;&lt;endl;</span><br>    <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span> == <span class="hljs-number">1</span>) C = C*A;<br>        A = A*A;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//cout&lt;&lt;C.m[1][1]&lt;&lt;&#x27; &#x27;&lt;&lt;C.m[1][2]&lt;&lt;endl&lt;&lt;C.m[2][1]&lt;&lt;&#x27; &#x27;&lt;&lt;C.m[2][2]&lt;&lt;endl;</span><br>    &#125;<br>    cout&lt;&lt;(C.m[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]+C.m[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>])%MOD;<br>&#125;<br></code></pre></td></tr></table></figure><br><a href="https://www.luogu.com.cn/problem/P1962">模板题(洛谷P1962)</a></p><p>完结撒花~</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速幂</tag>
      
      <tag>矩阵加速</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
